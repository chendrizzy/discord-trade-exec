/**
 * Polymarket Alert Model
 *
 * Stores alerts generated by intelligence analysis
 */

const mongoose = require('mongoose');

const polymarketAlertSchema = new mongoose.Schema({
  // Alert classification
  alertType: {
    type: String,
    required: true,
    enum: [
      'WHALE_BET',
      'VOLUME_SPIKE',
      'SENTIMENT_SHIFT',
      'ANOMALY',
      'COORDINATED_BETTING',
      'SUDDEN_REVERSAL',
      'FLASH_WHALE'
    ],
    index: true
  },

  severity: {
    type: String,
    required: true,
    enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
    index: true
  },

  // Alert content
  title: {
    type: String,
    required: true
  },

  description: String,

  // Context data
  context: {
    walletAddress: String,
    marketId: String,
    transactionHash: String,
    amount: Number,
    outcome: String,
    timeWindow: String,
    additionalData: mongoose.Schema.Types.Mixed
  },

  // Discord notification
  sentToDiscord: {
    type: Boolean,
    default: false
  },

  discordMessageId: String,
  discordChannelId: String,

  // User interaction
  dismissed: {
    type: Boolean,
    default: false
  },

  dismissedBy: String,
  dismissedAt: Date,

  // Metadata
  triggeredAt: {
    type: Date,
    default: Date.now,
    index: true
  },

  expiresAt: Date
}, {
  timestamps: true
});

// Indexes
polymarketAlertSchema.index({ alertType: 1, triggeredAt: -1 });
polymarketAlertSchema.index({ severity: 1, dismissed: 1, triggeredAt: -1 });
polymarketAlertSchema.index({ 'context.walletAddress': 1, triggeredAt: -1 });
polymarketAlertSchema.index({ 'context.marketId': 1, triggeredAt: -1 });

// Static helper methods for creating alerts

/**
 * Create whale bet alert
 */
polymarketAlertSchema.statics.createWhaleAlert = async function(data) {
  const severity = data.amount >= 500000 ? 'CRITICAL' :
                   data.amount >= 250000 ? 'HIGH' : 'MEDIUM';

  return this.create({
    alertType: 'WHALE_BET',
    severity,
    title: `üêã WHALE ALERT: $${(data.amount / 1000).toFixed(0)}K Bet`,
    description: `Whale wallet ${data.wallet.slice(0, 8)}... placed a $${data.amount.toLocaleString()} bet`,
    context: {
      walletAddress: data.wallet,
      marketId: data.marketId,
      transactionHash: data.txHash,
      amount: data.amount,
      outcome: data.outcome
    }
  });
};

/**
 * Create volume spike alert
 */
polymarketAlertSchema.statics.createVolumeSpikeAlert = async function(data) {
  return this.create({
    alertType: 'VOLUME_SPIKE',
    severity: 'HIGH',
    title: `üìà VOLUME SPIKE: ${data.spikePercentage}% increase`,
    description: `Market "${data.marketTitle}" volume spiked by ${data.spikePercentage}% in the last ${data.timeWindow}`,
    context: {
      marketId: data.marketId,
      amount: data.currentVolume,
      timeWindow: data.timeWindow,
      additionalData: {
        previousVolume: data.previousVolume,
        spikePercentage: data.spikePercentage
      }
    }
  });
};

/**
 * Create sentiment shift alert
 */
polymarketAlertSchema.statics.createSentimentShiftAlert = async function(data) {
  return this.create({
    alertType: 'SENTIMENT_SHIFT',
    severity: 'MEDIUM',
    title: `üîÑ SENTIMENT SHIFT: ${data.marketTitle}`,
    description: `Market sentiment shifted from ${data.previousOutcome} to ${data.newOutcome}`,
    context: {
      marketId: data.marketId,
      outcome: data.newOutcome,
      timeWindow: data.timeWindow,
      additionalData: {
        previousOutcome: data.previousOutcome,
        shiftPercentage: data.shiftPercentage
      }
    }
  });
};

/**
 * Create anomaly alert
 */
polymarketAlertSchema.statics.createAnomalyAlert = async function(data) {
  const severity = data.anomalyType === 'FLASH_WHALE' ? 'CRITICAL' : 'HIGH';

  return this.create({
    alertType: 'ANOMALY',
    severity,
    title: `‚ö†Ô∏è ANOMALY: ${data.anomalyType}`,
    description: data.description,
    context: {
      marketId: data.marketId,
      timeWindow: data.timeWindow,
      additionalData: data.details
    }
  });
};

/**
 * Create coordinated betting alert
 */
polymarketAlertSchema.statics.createCoordinatedBettingAlert = async function(data) {
  return this.create({
    alertType: 'COORDINATED_BETTING',
    severity: 'HIGH',
    title: `üë• COORDINATED BETTING: ${data.walletCount} wallets`,
    description: `${data.walletCount} wallets placed similar bets within ${data.timeWindow}`,
    context: {
      marketId: data.marketId,
      outcome: data.outcome,
      amount: data.totalAmount,
      timeWindow: data.timeWindow,
      additionalData: {
        wallets: data.wallets,
        averageBet: data.averageBet
      }
    }
  });
};

// Instance methods

/**
 * Dismiss alert
 */
polymarketAlertSchema.methods.dismiss = function(userId) {
  this.dismissed = true;
  this.dismissedBy = userId;
  this.dismissedAt = new Date();
  return this.save();
};

/**
 * Mark as sent to Discord
 */
polymarketAlertSchema.methods.markSentToDiscord = function(messageId, channelId) {
  this.sentToDiscord = true;
  this.discordMessageId = messageId;
  this.discordChannelId = channelId;
  return this.save();
};

// Static query methods

/**
 * Find recent alerts
 */
polymarketAlertSchema.statics.findRecent = function(hours = 24, limit = 100) {
  const since = new Date(Date.now() - hours * 60 * 60 * 1000);
  return this.find({ triggeredAt: { $gte: since } })
    .sort({ triggeredAt: -1 })
    .limit(limit);
};

/**
 * Find active alerts (not dismissed)
 */
polymarketAlertSchema.statics.findActive = function(limit = 50) {
  return this.find({ dismissed: false })
    .sort({ severity: 1, triggeredAt: -1 })
    .limit(limit);
};

/**
 * Find alerts by market
 */
polymarketAlertSchema.statics.findByMarket = function(marketId, limit = 20) {
  return this.find({ 'context.marketId': marketId })
    .sort({ triggeredAt: -1 })
    .limit(limit);
};

/**
 * Find alerts by wallet
 */
polymarketAlertSchema.statics.findByWallet = function(walletAddress, limit = 20) {
  return this.find({ 'context.walletAddress': walletAddress.toLowerCase() })
    .sort({ triggeredAt: -1 })
    .limit(limit);
};

const PolymarketAlert = mongoose.model('PolymarketAlert', polymarketAlertSchema);

module.exports = PolymarketAlert;
